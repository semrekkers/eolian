package main

import (
	"fmt"
	"log"
	"math"
	"os"
	"strings"
)

const (
	low        = 20.0
	high       = 10000.0
	sampleRate = 44100.0
)

var tables = []table{
	{"Gap", func(count uint) []float64 { return gen(count, gap, 0, true) }},
	{"Saw", func(count uint) []float64 { return gen(count, saw, 0.5, true) }},
	{"Sine", func(count uint) []float64 { return gen(count, sine, 0, false) }},
	{"Square", func(count uint) []float64 { return gen(count, square, 0, true) }},
	{"Triangle", func(count uint) []float64 { return gen(count, triangle, 0, true) }},
}

type table struct {
	Name     string
	Generate func(uint) []float64
}

func main() {
	breaks := []string{}
	for f := low / sampleRate; f <= high/sampleRate; f *= 2 {
		breaks = append(breaks, fmt.Sprintf("%f", f))
	}

	index := make([]string, len(tables))

	for i, t := range tables {
		func(t table) {
			name := strings.ToLower(t.Name) + ".go"
			fmt.Println(name)
			f, err := os.Create(name)
			if err != nil {
				log.Fatal(err)
			}
			defer f.Close()

			points := t.Generate(uint(len(breaks)))
			values := make([]string, len(points))
			for i, p := range points {
				values[i] = fmt.Sprintf("%v", p)
			}
			fmt.Fprintf(f, tableOutput, t.Name, len(points), strings.Join(values, ", "))
		}(t)

		index[i] = fmt.Sprintf("%q: %s[:]", strings.ToLower(t.Name), t.Name)
	}

	fmt.Println("shapes.go")
	f, err := os.Create("shapes.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	fmt.Fprintf(f, indexOutput, strings.Join(breaks, ", "), strings.Join(index, ", "))
}

const tableOutput = `// Generated by cmd/gen/main.go. DO NOT EDIT.
package wavetable

var %s = [%d]float64{%s}`

const indexOutput = `// Generated by cmd/gen/main.go. DO NOT EDIT.
package wavetable

var Breakpoints = []float64{%s}

var Tables = map[string][]float64{%s}`

type seriesFunc func(p float64, k int) float64

func triangle(p float64, k int) float64 {
	if k%2 != 0 {
		return 8.0 / (math.Pi * math.Pi) / (float64(k) * float64(k)) * math.Cos(2*math.Pi*float64(k)*(p+0.25))
	}
	return 0
}

func sine(p float64, k int) float64 {
	if k == 1 {
		return -math.Sin(2 * math.Pi * float64(k) * p)
	}
	return 0
}

func saw(p float64, k int) float64 {
	if k > 0 {
		return -2 / math.Pi / float64(k) * math.Sin(2*math.Pi*p*float64(k))
	}
	return 0
}

func square(p float64, k int) float64 {
	if k%2 != 0 {
		return -4 / math.Pi / float64(k) * math.Sin(2*math.Pi*p*float64(k))
	}
	return 0
}

func gap(p float64, k int) float64 {
	if k%3 == 0 {
		return 0
	}
	return 8 / 3 * math.Pi / float64(k) * math.Sin(2*math.Pi*float64(k)*(p+0.5))
}

const invSqrt2 = 1 / math.Sqrt2

func gen(count uint, series seriesFunc, phase float64, sigma bool) []float64 {
	var length uint = 4<<count - 1
	size := count * length
	allTables := make([]float64, size)

	var (
		point int
		i     uint
	)
	for ; i < count; i++ {
		harmonics := (1 << i) + 1

		var j uint
		for ; j < length; j++ {
			p := float64(j)/float64(length) + 0.5 + phase
			p -= float64(int(p))

			offset := series(p, 0)
			sum := offset

			for k := 1; k < harmonics; k++ {
				y := series(p, k)
				if sigma {
					x := math.Pi * float64(k) / float64(harmonics)
					y *= math.Sin(x) / x
				}
				sum += y
			}

			allTables[point] = invSqrt2 * sum
			point++
		}
	}

	return allTables
}
